# Modified from the file automatically generated by ProtoBuf.jl
# See https://github.com/pszufe/OpenStreetMapX.jl/pull/52/
# syntax: proto2
using ProtoBuf
import ProtoBuf.meta

mutable struct HeaderBBox <: SimpleProtoType
    left::Int64
    right::Int64
    top::Int64
    bottom::Int64
    function HeaderBBox()
        return new()
    end
end

const __meta_HeaderBBox = Ref{ProtoMeta}()
function meta(::Type{HeaderBBox})
    ProtoBuf.metalock() do
        if !isassigned(__meta_HeaderBBox)
            __meta_HeaderBBox[] = target = ProtoMeta(HeaderBBox)
            req = Symbol[:left,:right,:top,:bottom]
            wtype = Dict(:left => :sint64, :right => :sint64, :top => :sint64, :bottom => :sint64)
            allflds = Pair{Symbol,Union{Type,String}}[:left => Int64, :right => Int64, :top => Int64, :bottom => Int64]
            meta(target, HeaderBBox, allflds, req, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_HeaderBBox[]
    end
end

# TODO which subtype of `AbstractString` is actually used ?
mutable struct HeaderBlock <: SimpleProtoType
    bbox::HeaderBBox
    required_features::Vector{AbstractString}
    optional_features::Vector{AbstractString}
    writingprogram::AbstractString
    source::AbstractString
    osmosis_replication_timestamp::Int64
    osmosis_replication_sequence_number::Int64
    osmosis_replication_base_url::AbstractString

    function HeaderBlock()
        return new()
    end
end # mutable struct HeaderBlock
#function ProtoBuf.clear(obj::HeaderBlock)
#    if isdefined(obj, :required_features)
#        empty!(obj.required_features)
#    end
#    if isdefined(obj, :optional_features)
#        empty!(obj.optional_features)
#    end
#    return
#end
const __meta_HeaderBlock = Ref{ProtoMeta}()
function meta(::Type{HeaderBlock})
    ProtoBuf.metalock() do
        if !isassigned(__meta_HeaderBlock)
            __meta_HeaderBlock[] = target = ProtoMeta(HeaderBlock)
            fnum = Int[1,4,5,16,17,32,33,34]
            allflds = Pair{Symbol,Union{Type,String}}[:bbox => HeaderBBox, :required_features => Base.Vector{AbstractString}, :optional_features => Base.Vector{AbstractString}, :writingprogram => AbstractString, :source => AbstractString, :osmosis_replication_timestamp => Int64, :osmosis_replication_sequence_number => Int64, :osmosis_replication_base_url => AbstractString]
            meta(target, HeaderBlock, allflds, ProtoBuf.DEF_REQ, fnum, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_HeaderBlock[]
    end
end

mutable struct StringTable <: SimpleProtoType
    s::Vector{Vector{UInt8}}
    function StringTable()
        return new()
    end
end # mutable struct StringTable
#function ProtoBuf.clear(obj::StringTable)
#    if isdefined(obj, :s)
#        empty!(obj.s)
#    end
#    return
#end
const __meta_StringTable = Ref{ProtoMeta}()
function meta(::Type{StringTable})
    ProtoBuf.metalock() do
        if !isassigned(__meta_StringTable)
            __meta_StringTable[] = target = ProtoMeta(StringTable)
            allflds = Pair{Symbol,Union{Type,String}}[:s => Base.Vector{Vector{UInt8}}]
            meta(target, StringTable, allflds, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_StringTable[]
    end
end

mutable struct Info <: SimpleProtoType
    version::Int32
    timestamp::Int64
    changeset::Int64
    uid::Int32
    user_sid::UInt32
    visible::Bool
    function Info()
        obj = new()
        set_defaults!(obj)
        return obj
    end
end # mutable struct Info
function set_defaults!(obj::Info)
    obj.version = Int32(-1)
    return
end
const __meta_Info = Ref{ProtoMeta}()
function meta(::Type{Info})
    ProtoBuf.metalock() do
        if !isassigned(__meta_Info)
            __meta_Info[] = target = ProtoMeta(Info)
            val = Dict{Symbol,Any}(:version => -1)
            allflds = Pair{Symbol,Union{Type,String}}[:version => Int32, :timestamp => Int64, :changeset => Int64, :uid => Int32, :user_sid => UInt32, :visible => Bool]
            meta(target, Info, allflds, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, val, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_Info[]
    end
end

mutable struct DenseInfo <: SimpleProtoType
    version::Vector{Int32}
    timestamp::Vector{Int64}
    changeset::Vector{Int64}
    uid::Vector{Int32}
    user_sid::Vector{Int32}
    visible::Vector{Bool}
    function DenseInfo()
        return new()
    end
end # mutable struct DenseInfo
const __meta_DenseInfo = Ref{ProtoMeta}()
function meta(::Type{DenseInfo})
    ProtoBuf.metalock() do
        if !isassigned(__meta_DenseInfo)
            __meta_DenseInfo[] = target = ProtoMeta(DenseInfo)
            pack = Symbol[:version,:timestamp,:changeset,:uid,:user_sid,:visible]
            wtype = Dict(:timestamp => :sint64, :changeset => :sint64, :uid => :sint32, :user_sid => :sint32)
            allflds = Pair{Symbol,Union{Type,String}}[:version => Base.Vector{Int32}, :timestamp => Base.Vector{Int64}, :changeset => Base.Vector{Int64}, :uid => Base.Vector{Int32}, :user_sid => Base.Vector{Int32}, :visible => Base.Vector{Bool}]
            meta(target, DenseInfo, allflds, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, pack, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_DenseInfo[]
    end
end

mutable struct ChangeSet <: SimpleProtoType
    id::Int64
    function ChangeSet()
        return new()
    end
end # mutable struct ChangeSet
const __meta_ChangeSet = Ref{ProtoMeta}()
function meta(::Type{ChangeSet})
    ProtoBuf.metalock() do
        if !isassigned(__meta_ChangeSet)
            __meta_ChangeSet[] = target = ProtoMeta(ChangeSet)
            req = Symbol[:id]
            allflds = Pair{Symbol,Union{Type,String}}[:id => Int64]
            meta(target, ChangeSet, allflds, req, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_ChangeSet[]
    end
end

mutable struct Node <: SimpleProtoType
    id::Int64
    keys::Vector{UInt32}
    vals::Vector{UInt32}
    info::Info
    lat::Int64
    lon::Int64
    function Node()
        return new()
    end
end # mutable struct Node
const __meta_Node = Ref{ProtoMeta}()
function meta(::Type{Node})
    ProtoBuf.metalock() do
        if !isassigned(__meta_Node)
            __meta_Node[] = target = ProtoMeta(Node)
            req = Symbol[:id,:lat,:lon]
            fnum = Int[1,2,3,4,8,9]
            pack = Symbol[:keys,:vals]
            wtype = Dict(:id => :sint64, :lat => :sint64, :lon => :sint64)
            allflds = Pair{Symbol,Union{Type,String}}[:id => Int64, :keys => Base.Vector{UInt32}, :vals => Base.Vector{UInt32}, :info => Info, :lat => Int64, :lon => Int64]
            meta(target, Node, allflds, req, fnum, ProtoBuf.DEF_VAL, pack, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_Node[]
    end
end

mutable struct DenseNodes <: SimpleProtoType
    id::Vector{Int64}
    denseinfo::DenseInfo
    lat::Vector{Int64}
    lon::Vector{Int64}
    keys_vals::Vector{Int32}
    function DenseNodes()
        return new()
    end
end # mutable struct DenseNodes
const __meta_DenseNodes = Ref{ProtoMeta}()
function meta(::Type{DenseNodes})
    ProtoBuf.metalock() do
        if !isassigned(__meta_DenseNodes)
            __meta_DenseNodes[] = target = ProtoMeta(DenseNodes)
            fnum = Int[1,5,8,9,10]
            pack = Symbol[:id,:lat,:lon,:keys_vals]
            wtype = Dict(:id => :sint64, :lat => :sint64, :lon => :sint64)
            allflds = Pair{Symbol,Union{Type,String}}[:id => Base.Vector{Int64}, :denseinfo => DenseInfo, :lat => Base.Vector{Int64}, :lon => Base.Vector{Int64}, :keys_vals => Base.Vector{Int32}]
            meta(target, DenseNodes, allflds, ProtoBuf.DEF_REQ, fnum, ProtoBuf.DEF_VAL, pack, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_DenseNodes[]
    end
end

mutable struct Way <: SimpleProtoType
    id::Int64
    keys::Vector{UInt32}
    vals::Vector{UInt32}
    info::Info
    refs::Vector{Int64}
    lat::Vector{Int64}
    lon::Vector{Int64}
    function Way()
        return new()
    end
end # mutable struct Way
#function set_defaults!(obj::Way)
#    obj.keys = UInt32[]
#    obj.vals = UInt32[]
#end
const __meta_Way = Ref{ProtoMeta}()
function meta(::Type{Way})
    ProtoBuf.metalock() do
        if !isassigned(__meta_Way)
            __meta_Way[] = target = ProtoMeta(Way)
            req = Symbol[:id]
            fnum = Int[1,2,3,4,8,9,10]
            pack = Symbol[:keys,:vals,:refs,:lat,:lon]
            wtype = Dict(:refs => :sint64, :lat => :sint64, :lon => :sint64)
            allflds = Pair{Symbol,Union{Type,String}}[:id => Int64, :keys => Base.Vector{UInt32}, :vals => Base.Vector{UInt32}, :info => Info, :refs => Base.Vector{Int64}, :lat => Base.Vector{Int64}, :lon => Base.Vector{Int64}]
            meta(target, Way, allflds, req, fnum, ProtoBuf.DEF_VAL, pack, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_Way[]
    end
end

const Relation_MemberType = ["NODE", "WAY", "RELATION"]

mutable struct Relation <: SimpleProtoType
    id::Int64
    keys::Vector{UInt32}
    vals::Vector{UInt32}
    info::Info
    roles_sid::Vector{Int32}
    memids::Vector{Int64}
    types::Vector{Int32}
    function Relation()
        return new()
    end
end # mutable struct Relation

const __meta_Relation = Ref{ProtoMeta}()
function meta(::Type{Relation})
    ProtoBuf.metalock() do
        if !isassigned(__meta_Relation)
            __meta_Relation[] = target = ProtoMeta(Relation)
            req = Symbol[:id]
            fnum = Int[1,2,3,4,8,9,10]
            pack = Symbol[:keys,:vals,:roles_sid,:memids,:types]
            wtype = Dict(:memids => :sint64)
            allflds = Pair{Symbol,Union{Type,String}}[:id => Int64, :keys => Base.Vector{UInt32}, :vals => Base.Vector{UInt32}, :info => Info, :roles_sid => Base.Vector{Int32}, :memids => Base.Vector{Int64}, :types => Base.Vector{Int32}]
            meta(target, Relation, allflds, req, fnum, ProtoBuf.DEF_VAL, pack, wtype, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_Relation[]
    end
end

mutable struct PrimitiveGroup <: SimpleProtoType
    nodes::Vector{Node}
    dense::DenseNodes
    ways::Vector{Way}
    relations::Vector{Relation}
    changesets::Vector{ChangeSet}
    function PrimitiveGroup()
        return new()
    end
end # mutable struct PrimitiveGroup
const __meta_PrimitiveGroup = Ref{ProtoMeta}()
function meta(::Type{PrimitiveGroup})
    ProtoBuf.metalock() do
        if !isassigned(__meta_PrimitiveGroup)
            __meta_PrimitiveGroup[] = target = ProtoMeta(PrimitiveGroup)
            allflds = Pair{Symbol,Union{Type,String}}[:nodes => Base.Vector{Node}, :dense => DenseNodes, :ways => Base.Vector{Way}, :relations => Base.Vector{Relation}, :changesets => Base.Vector{ChangeSet}]
            meta(target, PrimitiveGroup, allflds, ProtoBuf.DEF_REQ, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_PrimitiveGroup[]
    end
end

mutable struct PrimitiveBlock <: SimpleProtoType
    stringtable::StringTable
    primitivegroup::Vector{PrimitiveGroup}
    granularity::Int32
    lat_offset::Int64
    lon_offset::Int64
    date_granularity::Int32
    function PrimitiveBlock()
        obj = new()
        set_defaults!(obj)
        return obj
    end
end # mutable struct PrimitiveBlock
function set_defaults!(obj::PrimitiveBlock)
    obj.granularity = Int32(100)
    obj.lat_offset = 0
    obj.lon_offset = 0
    obj.date_granularity = Int32(1000)
    return
end
#function ProtoBuf.clear(obj::PrimitiveBlock)
#    if isdefined(obj, :stringtable)
#        ProtoBuf.clear(obj.stringtable)
#    end
#    if isdefined(obj, :primitivegroup)
#        empty!(obj.primitivegroup)
#    end
#    return
#end
const __meta_PrimitiveBlock = Ref{ProtoMeta}()
function meta(::Type{PrimitiveBlock})
    ProtoBuf.metalock() do
        if !isassigned(__meta_PrimitiveBlock)
            __meta_PrimitiveBlock[] = target = ProtoMeta(PrimitiveBlock)
            req = Symbol[:stringtable]
            val = Dict{Symbol,Any}(:granularity => 100, :lat_offset => 0, :lon_offset => 0, :date_granularity => 1000)
            fnum = Int[1,2,17,19,20,18]
            allflds = Pair{Symbol,Union{Type,String}}[:stringtable => StringTable, :primitivegroup => Base.Vector{PrimitiveGroup}, :granularity => Int32, :lat_offset => Int64, :lon_offset => Int64, :date_granularity => Int32]
            meta(target, PrimitiveBlock, allflds, req, fnum, val, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_PrimitiveBlock[]
    end
end

export HeaderBlock, HeaderBBox, PrimitiveBlock, PrimitiveGroup, StringTable, Info, DenseInfo, ChangeSet, Node, DenseNodes, Way, Relation_MemberType, Relation
