# Automatically generated by ProtoBuf.jl
# syntax: proto2
using ProtoBuf
import ProtoBuf.meta

mutable struct Blob <: SimpleProtoType
    raw_size::Int32
    raw::Vector{UInt8}
    zlib_data::Vector{UInt8}
    lzma_data::Vector{UInt8}
    OBSOLETE_bzip2_data::Vector{UInt8}
    lz4_data::Vector{UInt8}
    zstd_data::Vector{UInt8}
    function Blob()
        return new()
    end
end # mutable struct Blob
const __meta_Blob = Ref{ProtoMeta}()
function meta(::Type{Blob})
    ProtoBuf.metalock() do
        if !isassigned(__meta_Blob)
            __meta_Blob[] = target = ProtoMeta(Blob)
            fnum = Int[2,1,3,4,5,6,7]
            allflds = Pair{Symbol,Union{Type,String}}[:raw_size => Int32, :raw => Vector{UInt8}, :zlib_data => Vector{UInt8}, :lzma_data => Vector{UInt8}, :OBSOLETE_bzip2_data => Vector{UInt8}, :lz4_data => Vector{UInt8}, :zstd_data => Vector{UInt8}]
            oneofs = Int[0,1,1,1,1,1,1]
            oneof_names = Symbol[Symbol("data")]
            meta(target, Blob, allflds, ProtoBuf.DEF_REQ, fnum, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, oneofs, oneof_names)
        end
        __meta_Blob[]
    end
end

mutable struct BlobHeader <: SimpleProtoType
    _type::AbstractString
    indexdata::Vector{UInt8}
    datasize::Int32
    function BlobHeader()
        return new()
    end
end # mutable struct BlobHeader
const __meta_BlobHeader = Ref{ProtoMeta}()
function meta(::Type{BlobHeader})
    ProtoBuf.metalock() do
        if !isassigned(__meta_BlobHeader)
            __meta_BlobHeader[] = target = ProtoMeta(BlobHeader)
            req = Symbol[:_type,:datasize]
            allflds = Pair{Symbol,Union{Type,String}}[:_type => AbstractString, :indexdata => Vector{UInt8}, :datasize => Int32]
            meta(target, BlobHeader, allflds, req, ProtoBuf.DEF_FNUM, ProtoBuf.DEF_VAL, ProtoBuf.DEF_PACK, ProtoBuf.DEF_WTYPES, ProtoBuf.DEF_ONEOFS, ProtoBuf.DEF_ONEOF_NAMES)
        end
        __meta_BlobHeader[]
    end
end

export Blob, BlobHeader
